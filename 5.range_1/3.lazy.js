import { log } from '../fx.js'

// # 지연 평가 - 게으르다. 혹은 영리하다?
// 필요할 때까지 평가를 미루다가 평가가 필요할 때 평가를 하는 기법
// 큰 크기의 배열을 미리 만드는 것이 아니라 필요한 값이 필요할 때만 배열의 안쪽에 있는 값들을 만들어내면서
// 값을 만드는 것을 최소화하여 연산을 줄이는 아이디어이다.

// 이전의 자바스크립트에서는 구현은 가능했지만 언어에서 지원을 하지 않았기에 공식적이진 않았다.
// 지연평가를 위한 연산이 많이 필요했다. 그리고 다른 라이브러리들끼리 사용하기 힘들었다.
// 그러다 새로운 자바스크립트에서는 이터러블 이터레이터 프로토콜 덕분에
// 지연평가나 코드를 값으로 다루는 프로그래밍을 할 때,
// 공식적인 자바스크립트의 일반 값으로 구현 가능해졌다.

// 이터러블 중심 프로그래밍(리트스 중심, 콜렉션 중심 프로그래밍)

// 지연성을 가진 함수로 만들기
// 제너레이터, 이터레이터 프로토콜로 구현

// L.map
// 평가를 미루는 성질을 가지고 조금 평가 순서를 달리 조작할수 있는
// 준비가 되어있는 그런 이터레이터를 반환하는 제너레이터 함수
const L = {}

L.map1 = function* (iter) {
  for (const a of iter) {
    yield a;
  }
}

const it1 = L.map1([1, 2, 3]); // 이것 만으로는 평가되지 않는다.
log(it1.next());
log(it1.next());
log(it1.next());

L.map = function* (fn, iter) {
  for (const a of iter) {
    yield fn(a);
  }
}

const it2 = L.map(n => n * n, [1, 2, 3]); // 함수를 적용한 값을 다시 만들어야 한다.
log(it2.next());
log(it2.next());
log(it2.next());
const it3 = L.map(n => n * n, [1, 2, 3]);
console.log(...it3); // 이터레이터이기 때문에 스프레이드 연산자도 사용 가능하다.
// L.map 자체에서는 새로운 array를 만들지 않고 그냥 값 하나하나마다 순회하며 yield를 통해 함수가 적용된 값을 next가 실행될 때 마다 하나씩 전달하게 되고
// 그런 준비가 돼 있는 이터레이터 객체를 내가 원하는 방법으로 평가하면서 그런 준비가 돼 있는 L.map을 위 처럼 구현 가능하다.

L.filter = function* (fn, iter) {
  for (const i of iter) {
    if (fn(i)) {
      yield i;
    }
  }
}

const list = [1, 2, 3, 4, 5];

const it4 = L.filter(n => n % 2, list);
log(it4.next());
log(it4.next());
log(it4.next());
log(it4.next());
// 원하는 상황에서만 yield가 되는 식으로 구현


